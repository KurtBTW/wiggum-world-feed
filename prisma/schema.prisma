// Last Network - Database Schema
// PostgreSQL for production

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// AUTH MODELS (NextAuth.js)
// ============================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?
  
  role          UserRole  @default(APPLICANT)
  
  accounts      Account[]
  sessions      Session[]
  applications  Application[]
  memberships   NetworkMember[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ============================================
// ENUMS
// ============================================

enum UserRole {
  APPLICANT
  MEMBER
  ADMIN
}

enum ApplicationStatus {
  DRAFT
  SUBMITTED
  AI_SCREENING
  NEEDS_INFO
  UNDER_REVIEW
  APPROVED
  REJECTED
}

enum TweetCategory {
  ANNOUNCEMENT
  METRICS
  COMMENTARY
  THREAD
  NOISE
  UNCATEGORIZED
}

enum AccountType {
  PROTOCOL
  FOUNDER
  TEAM
}

// ============================================
// LAST NETWORK MODELS
// ============================================

// Network member (approved project/protocol)
model NetworkMember {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  
  // Basic info
  name            String
  slug            String   @unique
  logo            String?
  website         String
  twitter         String?
  discord         String?
  github          String?
  description     String   @db.Text
  
  // Classification
  category        String   // lending, dex, derivatives, infrastructure, tooling, analytics
  stage           String   // live, testnet, building
  
  // Network participation
  seeking         String[] // listing, lp_intros, distribution, other
  offering        String[] // liquidity, integration, other
  
  // From application
  applicationId   String?  @unique
  application     Application? @relation(fields: [applicationId], references: [id])
  
  joinedAt        DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  twitterAccounts TwitterAccount[]
  
  @@index([category])
  @@index([stage])
  @@index([userId])
}

model TwitterAccount {
  id              String      @id @default(uuid())
  username        String      @unique
  displayName     String
  profileImageUrl String?
  twitterId       String?     @unique
  
  accountType     AccountType @default(PROTOCOL)
  personName      String?
  personRole      String?
  
  memberId        String?
  member          NetworkMember? @relation(fields: [memberId], references: [id])
  
  isActive        Boolean     @default(true)
  lastFetchedAt   DateTime?
  
  tweets          Tweet[]
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@index([memberId])
  @@index([isActive])
}

model Tweet {
  id              String        @id @default(uuid())
  tweetId         String        @unique
  
  accountId       String
  account         TwitterAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  text            String        @db.Text
  category        TweetCategory @default(UNCATEGORIZED)
  categoryReason  String?
  
  isThread        Boolean       @default(false)
  threadId        String?
  replyToId       String?
  
  likeCount       Int           @default(0)
  retweetCount    Int           @default(0)
  replyCount      Int           @default(0)
  viewCount       Int?
  
  mediaUrls       String[]
  urls            String[]
  mentions        String[]
  hashtags        String[]
  
  isHidden        Boolean       @default(false)
  isPinned        Boolean       @default(false)
  
  publishedAt     DateTime
  fetchedAt       DateTime      @default(now())
  classifiedAt    DateTime?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@index([accountId])
  @@index([category])
  @@index([publishedAt])
  @@index([isHidden])
}

// Application for network membership
model Application {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  
  // Project info
  projectName     String
  website         String
  twitter         String?
  discord         String?
  github          String?
  contactEmail    String
  
  // Details
  description     String   @db.Text
  teamInfo        String   @db.Text
  stage           String   // live, testnet, building
  category        String   // lending, dex, derivatives, infrastructure, tooling, analytics
  
  // What they seek
  seekingListing      Boolean @default(false)
  seekingLPIntros     Boolean @default(false)
  seekingDistribution Boolean @default(false)
  seekingOther        String?
  
  // What they offer
  offeringLiquidity   Boolean @default(false)
  offeringIntegration Boolean @default(false)
  offeringOther       String?
  
  // Proof of work
  proofOfWork     String?  @db.Text
  logoUrl         String?
  attachmentUrls  String[]
  
  // AI Screening
  aiScore         Int?
  aiSummary       String?  @db.Text
  aiFlags         String[]
  aiScreenedAt    DateTime?
  
  // Review
  status          ApplicationStatus @default(DRAFT)
  reviewerNotes   String?  @db.Text
  reviewedBy      String?
  reviewedAt      DateTime?
  
  // If approved, link to member
  member          NetworkMember?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([status])
  @@index([userId])
  @@index([createdAt])
}

// ============================================
// NEWS AGGREGATOR MODELS (preserved)
// ============================================

// Ingested items from RSS feeds and APIs
model IngestedItem {
  id            String   @id @default(uuid())
  title         String
  originalTitle String
  url           String   @unique
  canonicalUrl  String?
  imageUrl      String?
  source        String
  sourceName    String
  category      String   // defi_alpha, token_launches, security_alerts, ai_frontier
  publishedAt   DateTime
  fetchedAt     DateTime @default(now())
  excerpt       String?
  snippet       String?
  
  // Scoring fields
  optimismScore        Float @default(0)
  sensationalismScore  Float @default(0)
  forwardProgressScore Float @default(0)
  freshnessScore       Float @default(0)
  credibilityScore     Float @default(0)
  topicFitScore        Float @default(0)
  totalScore           Float @default(0)
  
  // Relevancy score (0-100) - how relevant to HypurrFi users
  relevancyScore       Int?
  relevancyReason      String? // Brief explanation of the score
  
  // Token-specific fields (for token_launches category)
  chainId       String?  // solana, ethereum, base, etc.
  tokenAddress  String?
  tokenSymbol   String?
  priceUsd      Float?
  priceChange24h Float?
  volume24h     Float?
  liquidity     Float?
  fdv           Float?   // Fully diluted valuation
  pairAddress   String?
  dexId         String?
  
  // Security fields (from GoPlus)
  securityScore Int?     // 0-100
  riskLevel     String?  // safe, low, medium, high, critical
  isHoneypot    Boolean?
  securityData  String?  // Full JSON security data
  
  // DeFi-specific fields (for defi_alpha category)
  tvl           Float?
  tvlChange24h  Float?
  apy           Float?
  protocolName  String?
  
  // Processing status
  processed       Boolean @default(false)
  selectedForTile Boolean @default(false)
  hiddenBySecurity Boolean @default(false) // Auto-hidden due to security issues
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  tileItems    TileItem[]
  chatMessages ChatMessage[]
  
  @@index([category])
  @@index([publishedAt])
  @@index([totalScore])
  @@index([chainId])
  @@index([riskLevel])
}

// Tile snapshots - persisted for "no new keep tile" behavior
model TileSnapshot {
  id        String   @id @default(uuid())
  category  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Snapshot metrics
  avgSensationalism  Float @default(0)
  avgOptimism        Float @default(0)
  forwardProgressPct Float @default(0)
  itemCount          Int   @default(0)
  sourceDiversity    Int   @default(0)
  
  // Wiggum loop metadata
  wiggumPasses    Int     @default(0)
  acceptedAtPass  Int?
  finalThresholds String? // JSON string of final thresholds used
  
  // Items in this snapshot
  items TileItem[]
  
  @@index([category])
  @@index([createdAt])
}

// Items belonging to a tile snapshot
model TileItem {
  id             String   @id @default(uuid())
  snapshotId     String
  ingestedItemId String
  position       Int      @default(0)
  
  // Calm summary (rewritten)
  calmHeadline String
  calmSummary  String
  
  createdAt DateTime @default(now())
  
  snapshot     TileSnapshot @relation(fields: [snapshotId], references: [id], onDelete: Cascade)
  ingestedItem IngestedItem @relation(fields: [ingestedItemId], references: [id])
  
  @@index([snapshotId])
}

// Cached market data for sidebar display
model MarketData {
  id          String   @id @default(uuid())
  symbol      String   // BTC, ETH, SOL, HYPE
  name        String
  price       Float
  change24h   Float    // percentage
  volume24h   Float?
  marketCap   Float?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([symbol])
  @@index([symbol])
}

// Chat history for the assistant
model ChatMessage {
  id        String   @id @default(uuid())
  sessionId String
  role      String   // user, assistant, system
  content   String
  
  // Context binding
  boundItemId String?
  boundItem   IngestedItem? @relation(fields: [boundItemId], references: [id])
  
  createdAt DateTime @default(now())
  
  @@index([sessionId])
  @@index([createdAt])
}

// Trending tokens cache (from DEX Screener)
model TrendingToken {
  id            String   @id @default(uuid())
  chainId       String
  tokenAddress  String
  symbol        String
  name          String
  priceUsd      Float
  priceChange24h Float
  volume24h     Float
  liquidity     Float
  fdv           Float?
  pairAddress   String
  dexId         String
  url           String
  imageUrl      String?
  
  // Security data
  securityScore Int?
  riskLevel     String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([chainId, tokenAddress])
  @@index([chainId])
  @@index([priceChange24h])
}

// Wiggum loop iteration logs for debugging
model WiggumLoopLog {
  id         String  @id @default(uuid())
  category   String
  passNumber Int
  
  // Input state
  inputMetrics    String // JSON
  inputThresholds String // JSON
  
  // Output state
  accepted       Boolean
  adjustments    String? // JSON of adjustments made
  failureReasons String? // JSON array of why not accepted
  
  createdAt DateTime @default(now())
  
  @@index([category])
  @@index([createdAt])
}
